/*
This function computes the Kronecker product of two vectors a and b.
*/
vector kronecker(vector a, vector b) {
  int n_a = rows(a);
  int n_b = rows(b);
  vector[n_a * n_b] result;
  
  for (i in 1:n_a) {
    for (j in 1:n_b) {
      result[(i-1)*n_b + j] = a[i] * b[j];
    }
  }
  
  return result;
}

/*
This function generates the precision matrix for an AR1 process with a given correlation parameter rho.
*/
matrix ar1_precision(int n, real rho) {
  matrix[n, n] Q;
  real scaling = 1.0 / (1.0 - rho * rho);
  real off_diag = -rho * scaling;

  Q = rep_matrix(0, n, n);
  for (i in 1:n) {
    Q[i, i] = (i == 1 || i == n) ? scaling : (1.0 + rho * rho) * scaling;
    if (i > 1) Q[i, i-1] = off_diag;
    if (i < n) Q[i, i+1] = off_diag;
  }
  return Q;
}

/*
This function takes as input the eigendecomposition of two matrices Q1 and Q2 and 
returns the marginal standard deviations of the matrix Q, defined as the
kronecker sum of Q1 and Q2 with smoothness parameter nu.
*/
vector marginal_sd(tuple(matrix, vector) E1, tuple(matrix, vector) E2, real nu) {
  int dim1 = cols(E1.1);
  int dim2 = cols(E2.1);

  matrix[dim1, dim1] V1 = E1.1;
  vector[dim1] A1 = E1.2;
  matrix[dim2, dim2] V2 = E2.1;
  vector[dim2] A2 = E2.2;


vector[dim1 * dim2] marginal_sds = rep_vector(0.0, dim1 * dim2);
for (i in 1:dim1) {
  for (j in 1:dim2) {
    vector[dim1 * dim2] v = kronecker(V1[, i], V2[, j]);
    real lambda = pow(A1[i] + A2[j], nu + 1);
    marginal_sds += square(v) / lambda;
  }
}
return sqrt(marginal_sds);
}

real matern_copula_exact_lpdf(matrix Z, tuple(matrix, vector) E1, tuple(matrix, vector) E2, int nu) {
  int n_obs = cols(Z);
  int dim1 = cols(E1.1);
  int dim2 = cols(E2.1);
  int D = dim1 * dim2;
  vector[D] marginal_sds = marginal_sd(E1, E2, nu);

  real log_det = 0;
  real quadform_sum = 0;

  for (i in 1:dim1) {
    for (j in 1:dim2) {
      vector[D] v = kronecker(E1.1[, i], E2.1[, j]);
      v = v .* marginal_sds;  
      real norm_v = sqrt(sum(square(v)));
      v /= norm_v;  
      
      real lambda = pow(E1.2[i] + E2.2[j], nu + 1) * square(norm_v);
      log_det += log(lambda);
      
      row_vector[n_obs] q = v' * Z;  
      quadform_sum += dot_self(q) * lambda;
    }
  }

  real z_squared = sum(columns_dot_self(Z));

  return -0.5 * (quadform_sum - n_obs * log_det - z_squared);
}

real matern_exact_lpdf(matrix Z, tuple(matrix, vector) E1, tuple(matrix, vector) E2, int nu) {
  int n_obs = cols(Z);
  int dim1 = cols(E1.1);
  int dim2 = cols(E2.1);
  int D = dim1 * dim2;

  real log_det = 0;
  real quadform_sum = 0;

  for (i in 1:dim1) {
    for (j in 1:dim2) {
      vector[D] v = kronecker(E1.1[, i], E2.1[, j]);
      
      real lambda = pow(E1.2[i] + E2.2[j], nu + 1);
      log_det += log(lambda);
      
      row_vector[n_obs] q = v' * Z;  
      quadform_sum += dot_self(q) * lambda;
    }
  }

  return -0.5 * (quadform_sum - n_obs * log_det);
}